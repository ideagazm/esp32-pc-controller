#!/usr/bin/env python3
"""
ESP32 PC Controller Template Generator
Creates organized deployment folders for each PC with all necessary files
"""

import os
import configparser
import shutil
from pathlib import Path

class TemplateGenerator:
    def __init__(self, config_file="config.ini"):
        self.config = configparser.ConfigParser()
        self.config.read(config_file)
        self.script_dir = Path(__file__).parent
        self.base_config_file = config_file
        
    def generate_all(self):
        """Generate all deployment files"""
        print("ESP32 PC Controller Template Generator")
        print("=" * 50)
        
        # Get configuration
        num_pcs = int(self.config.get('GENERAL', 'num_pcs'))
        deployment_path = self.config.get('GENERAL', 'deployment_path')
        
        # Check if deployment folder has its own config and use it instead
        deploy_config_path = Path(deployment_path) / "config.ini"
        if deploy_config_path.exists():
            print(f"üìã Using existing config from: {deploy_config_path}")
            self.config.read(deploy_config_path)
            # Re-read values from deployment config
            num_pcs = int(self.config.get('GENERAL', 'num_pcs'))
        else:
            print(f"üìã Using base config from: {self.base_config_file}")
        
        print(f"Number of PCs: {num_pcs}")
        print(f"Deployment path: {deployment_path}")
        print()
        
        # Create main deployment directory
        deploy_dir = Path(deployment_path)
        
        # Backup existing deployment if it exists
        if deploy_dir.exists() and any(deploy_dir.iterdir()):
            import time
            backup_dir = Path(f"{deployment_path}_backup_{int(time.time())}")
            print(f"üì¶ Backing up existing deployment to: {backup_dir}")
            shutil.copytree(deploy_dir, backup_dir)
        
        deploy_dir.mkdir(parents=True, exist_ok=True)
        
        # Copy config file to deployment folder for user editing
        self.copy_config_to_deployment(deploy_dir)
        
        # Generate ESP32 YAML file
        self.generate_esp32_yaml(deploy_dir)
        
        # Generate PC folders and files
        for pc_num in range(1, num_pcs + 1):
            self.generate_pc_folder(deploy_dir, pc_num)
            
        success_msg = "Deployment complete!"
        config_tip = f"Edit {deployment_path}/config.ini for further customization"
        print(f"\n‚úÖ {success_msg}")
        print(f"üìÅ Files created in: {deployment_path}")
        print(f"üîß {config_tip}")
        print("ÔøΩ The oriiginal config.ini in development/ remains as a clean template")
        
    def copy_config_to_deployment(self, deploy_dir):
        """Copy config.ini to deployment folder for user editing (only if it doesn't exist)"""
        source_config = Path("config.ini")
        dest_config = deploy_dir / "config.ini"
        
        if dest_config.exists():
            print(f"üìã Using existing config: {dest_config}")
        else:
            print("üìã Copying configuration file...")
            try:
                shutil.copy2(source_config, dest_config)
                os.chmod(dest_config, 0o644)
                print(f"   ‚úÖ Created: {dest_config}")
                print("   ‚ÑπÔ∏è  Edit this config file to customize your deployment")
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Warning: Could not copy config file: {e}")
        
        # Always create/update deployment README
        self.create_deployment_readme(deploy_dir)
            
    def create_deployment_readme(self, deploy_dir):
        """Create README for the deployment folder"""
        readme_content = '''# ESP32 PC Controller - Deployment Package

This folder contains your customized ESP32 PC controller deployment.

## Contents

- config.ini - Your configuration file (EDIT THIS for customization)
- pc_controller.yaml - ESP32 firmware configuration  
- pc1/, pc2/, etc. - Individual PC folders with scripts

## Customization

1. Edit config.ini in this folder to customize:
   - PC names, MAC addresses, IP addresses
   - ESP32 network settings
   - GPIO pin assignments

2. Regenerate by running the template generator again
   - It will use the config.ini from this folder
   - Original template in development/ stays clean

## Deployment Steps

1. Configure ESPHome Secrets (see docs/SECURITY_SETUP.md)
2. Flash ESP32 with pc_controller.yaml
3. Copy PC folders to respective computers
4. Run setup scripts on each PC

## Documentation

See the development/docs/ folder for:
- SECURITY_SETUP.md - Required secrets configuration
- DEPLOYMENT_CHECKLIST.md - Step-by-step deployment guide
- INSTALLATION_GUIDE.md - Detailed setup instructions

Generated by ESP32 PC Controller Template Generator
'''
        
        readme_file = deploy_dir / "README.md"
        try:
            with open(readme_file, 'w') as f:
                f.write(readme_content)
            os.chmod(readme_file, 0o644)
            print(f"   ‚úÖ Created: {readme_file}")
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Warning: Could not create README: {e}")
        
    def generate_esp32_yaml(self, deploy_dir):
        """Generate the ESP32 YAML configuration"""
        print("üìù Generating ESP32 YAML configuration...")
        
        # Read ESP32 config
        esp32_config = dict(self.config['ESP32'])
        num_pcs = int(self.config.get('GENERAL', 'num_pcs'))
        
        # Build substitutions section
        substitutions = []
        substitutions.append(f'  device_name: "{esp32_config["device_name"]}"')
        substitutions.append(f'  friendly_name: "{esp32_config["friendly_name"]}"')
        substitutions.append('')
        
        # Add PC configurations
        for pc_num in range(1, num_pcs + 1):
            pc_section = f'PC{pc_num}'
            if pc_section in self.config:
                pc_config = dict(self.config[pc_section])
                substitutions.append(f'  # PC {pc_num} Configuration')
                substitutions.append(f'  pc{pc_num}_name: "{pc_config["name"]}"')
                substitutions.append(f'  pc{pc_num}_mac: "{pc_config["mac_address"]}"')
                substitutions.append(f'  pc{pc_num}_ip: "{pc_config["ip_address"]}"')
                substitutions.append(f'  pc{pc_num}_on_button_gpio: "{pc_config["on_button_gpio"]}"')
                substitutions.append(f'  pc{pc_num}_off_button_gpio: "{pc_config["off_button_gpio"]}"')
                substitutions.append('')
        
        # Generate YAML content
        yaml_content = self.get_yaml_template(substitutions, esp32_config, num_pcs)
        
        # Write YAML file
        yaml_file = deploy_dir / "pc_controller.yaml"
        with open(yaml_file, 'w') as f:
            f.write(yaml_content)
        
        # Set appropriate file permissions
        os.chmod(yaml_file, 0o644)
        print(f"   ‚úÖ Created: {yaml_file}")
        
    def generate_pc_folder(self, deploy_dir, pc_num):
        """Generate folder and files for a specific PC"""
        pc_section = f'PC{pc_num}'
        if pc_section not in self.config:
            print(f"   ‚ö†Ô∏è  No configuration found for PC{pc_num}, skipping...")
            return
            
        pc_config = dict(self.config[pc_section])
        esp32_ip = self.config.get('ESP32', 'static_ip')
        
        print(f"üìÅ Generating PC{pc_num} folder ({pc_config['name']})...")
        
        # Create PC folder using PC name
        pc_folder = deploy_dir / pc_config['name'].lower()
        pc_folder.mkdir(exist_ok=True)
        
        # Generate Python shutdown script
        python_script = self.get_python_script_template(pc_num, pc_config, esp32_ip)
        python_file = pc_folder / f"{pc_config['name'].lower()}_shutdown.py"
        with open(python_file, 'w') as f:
            f.write(python_script)
        print(f"   ‚úÖ Created: {python_file}")
        
        # Generate run batch file
        run_batch = self.get_run_batch_template(pc_num, pc_config, esp32_ip)
        run_file = pc_folder / f"run_{pc_config['name'].lower()}.bat"
        with open(run_file, 'w') as f:
            f.write(run_batch)
        os.chmod(run_file, 0o755)  # Make executable
        print(f"   ‚úÖ Created: {run_file}")
        
        # Generate service installer batch file
        service_batch = self.get_service_batch_template(pc_num, pc_config)
        service_file = pc_folder / f"install_{pc_config['name'].lower()}_service.bat"
        with open(service_file, 'w') as f:
            f.write(service_batch)
        os.chmod(service_file, 0o755)  # Make executable
        print(f"   ‚úÖ Created: {service_file}")
        
        # Generate README for this PC
        readme_content = self.get_pc_readme_template(pc_num, pc_config, esp32_ip)
        readme_file = pc_folder / "README.txt"
        with open(readme_file, 'w') as f:
            f.write(readme_content)
        print(f"   ‚úÖ Created: {readme_file}")
        
    def get_yaml_template(self, substitutions, esp32_config, num_pcs):
        """Generate the ESP32 YAML template"""
        substitutions_str = '\n'.join(substitutions)
        
        # Generate text sensors
        text_sensors = []
        for pc_num in range(1, num_pcs + 1):
            pc_section = f'PC{pc_num}'
            if pc_section in self.config:
                pc_name_lower = self.config.get(pc_section, 'name').lower()
                text_sensors.append(f'''  - platform: template
    name: "${{pc{pc_num}_name}} Status"
    id: {pc_name_lower}_status
    icon: "mdi:desktop-tower"''')
        
        # Generate binary sensors (buttons)
        binary_sensors = []
        for pc_num in range(1, num_pcs + 1):
            pc_section = f'PC{pc_num}'
            if pc_section in self.config:
                pc_name_lower = self.config.get(pc_section, 'name').lower()
                binary_sensors.append(f'''  # PC{pc_num} ON button
  - platform: gpio
    pin:
      number: ${{pc{pc_num}_on_button_gpio}}
      mode:
        input: true
        pullup: true
      inverted: true
    name: "${{pc{pc_num}_name}} ON Button"
    id: {pc_name_lower}_on_btn
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - button.press: {pc_name_lower}_wol_button

  # PC{pc_num} OFF button
  - platform: gpio
    pin:
      number: ${{pc{pc_num}_off_button_gpio}}
      mode:
        input: true
        pullup: true
      inverted: true
    name: "${{pc{pc_num}_name}} OFF Button"
    id: {pc_name_lower}_off_btn
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - http_request.post:
          url: "http://${{pc{pc_num}_ip}}:5000/shutdown"
          request_headers:
            Content-Type: "application/json"
          json:
            command: "shutdown"
          on_response:
            then:
              - lambda: |-
                  if (response->status_code == 200) {{
                    id({pc_name_lower}_status).publish_state("Shutdown command sent");
                  }} else {{
                    id({pc_name_lower}_status).publish_state("Shutdown failed");
                  }}
          on_error:
            then:
              - lambda: |-
                  id({pc_name_lower}_status).publish_state("Connection error");''')
        
        # Generate buttons (WOL and web shutdown)
        buttons = []
        for pc_num in range(1, num_pcs + 1):
            pc_section = f'PC{pc_num}'
            if pc_section in self.config:
                pc_name_lower = self.config.get(pc_section, 'name').lower()
                buttons.append(f'''  # PC{pc_num} Wake-on-LAN
  - platform: wake_on_lan
    name: "${{pc{pc_num}_name}} Wake on LAN"
    id: {pc_name_lower}_wol_button
    target_mac_address: ${{pc{pc_num}_mac}}
    on_press:
      - text_sensor.template.publish:
          id: {pc_name_lower}_status
          state: "WOL packet sent"

  # PC{pc_num} Shutdown (web button)
  - platform: template
    name: "${{pc{pc_num}_name}} Shutdown"
    id: {pc_name_lower}_shutdown_button
    on_press:
      - http_request.post:
          url: "http://${{pc{pc_num}_ip}}:5000/shutdown"
          request_headers:
            Content-Type: "application/json"
          json:
            command: "shutdown"
          on_response:
            then:
              - lambda: |-
                  if (response->status_code == 200) {{
                    id({pc_name_lower}_status).publish_state("Shutdown command sent");
                  }} else {{
                    id({pc_name_lower}_status).publish_state("Shutdown failed");
                  }}
          on_error:
            then:
              - lambda: |-
                  id({pc_name_lower}_status).publish_state("Connection error");''')
        
        return f'''# ESPHome Configuration for PC Control with WOL and Shutdown
# Generated by ESP32 PC Controller Template Generator
# Supports {num_pcs} PCs with Wake-on-LAN and shutdown capability

substitutions:
{substitutions_str}

esphome:
  name: ${{device_name}}
  friendly_name: ${{friendly_name}}

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API (optional - remove if not using HA)
api:
  encryption:
    key: !secret api_key

# Enable Over-The-Air updates
ota:
  - platform: esphome

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: {esp32_config['static_ip']}
    gateway: {esp32_config['gateway']}
    subnet: {esp32_config['subnet']}
    dns1: {esp32_config['dns']}

  # Enable fallback hotspot in case wifi connection fails
  ap:
    ssid: "${{device_name}} Fallback"
    password: !secret fallback_password

# Enable web server for debugging and REST API
web_server:
  port: 80
  version: 2

# Text sensors to display status from Python scripts
text_sensor:
{chr(10).join(text_sensors)}

# Binary sensors for physical buttons
binary_sensor:
{chr(10).join(binary_sensors)}

# HTTP request component for shutdown commands
http_request:
  timeout: 5s
  verify_ssl: false

# Wake-on-LAN and Shutdown buttons
button:
{chr(10).join(buttons)}
'''

    def get_python_script_template(self, pc_num, pc_config, esp32_ip):
        """Generate Python shutdown script for a specific PC"""
        return f'''#!/usr/bin/env python3
"""
PC{pc_num} ({pc_config['name']}) Shutdown Script
This script receives shutdown commands from ESP32 and sends status back
Run this script on {pc_config['name']} to enable remote shutdown control

Installation:
1. Install required packages: pip install flask requests
2. Run: python pc{pc_num}_shutdown.py
3. For auto-start on boot, run install_pc{pc_num}_service.bat as Administrator

Generated by ESP32 PC Controller Template Generator
"""

import os
import sys
import requests
from flask import Flask, request, jsonify
import threading
import time
import logging
from urllib.parse import quote

app = Flask(__name__)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("pc_shutdown.log"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)

# Configuration - Auto-generated from config.ini
ESP32_IP = "{esp32_ip}"
ESP32_PORT = 80
PC_NAME = "{pc_config['name']}"
PC_NUMBER = {pc_num}


def send_status_to_esp32(status_message):
    """Send status update to ESP32"""
    try:
        # URL encode the status message to handle special characters
        encoded_message = quote(status_message)
        url = f"http://{{ESP32_IP}}:{{ESP32_PORT}}/text_sensor/{pc_config['name'].lower()}_status/set?value={{encoded_message}}"
        response = requests.get(url, timeout=5)
        logger.info(
            f"Status sent to ESP32: {{status_message}} - Response: {{response.status_code}}"
        )
        return response.status_code == 200
    except requests.exceptions.Timeout:
        logger.warning(f"Timeout sending status to ESP32: {{status_message}}")
        return False
    except requests.exceptions.ConnectionError:
        logger.warning(f"Connection error sending status to ESP32: {{status_message}}")
        return False
    except Exception as e:
        logger.error(f"Failed to send status to ESP32: {{e}}")
        return False


def shutdown_pc():
    """Shutdown the PC with a delay to allow status to be sent"""
    logger.info("Shutdown initiated - PC will shutdown in 5 seconds...")
    send_status_to_esp32("Shutting down in 5s...")
    time.sleep(2)

    send_status_to_esp32("Shutting down in 3s...")
    time.sleep(2)

    send_status_to_esp32("Shutting down now...")
    time.sleep(1)

    try:
        # Windows shutdown command
        if sys.platform == "win32":
            logger.info("Executing Windows shutdown command")
            os.system("shutdown /s /t 1")
        # Linux shutdown command
        elif sys.platform == "linux":
            logger.info("Executing Linux shutdown command")
            os.system("sudo shutdown -h now")
        # macOS shutdown command
        elif sys.platform == "darwin":
            logger.info("Executing macOS shutdown command")
            os.system("sudo shutdown -h now")
        else:
            logger.error(f"Unsupported platform: {{sys.platform}}")
            send_status_to_esp32("Shutdown failed - unsupported OS")
    except Exception as e:
        logger.error(f"Shutdown command failed: {{e}}")
        send_status_to_esp32("Shutdown failed")


@app.route("/shutdown", methods=["POST"])
def shutdown():
    """Handle shutdown request from ESP32"""
    try:
        data = request.get_json()
        if not data:
            logger.warning("Received shutdown request with no JSON data")
            return jsonify({{"status": "error", "message": "No JSON data provided"}}), 400

        command = data.get("command", "")

        if command == "shutdown":
            logger.info(f"Shutdown command received from {{request.remote_addr}}")
            send_status_to_esp32("Command received")

            # Start shutdown in a separate thread to allow response to be sent
            shutdown_thread = threading.Thread(target=shutdown_pc)
            shutdown_thread.daemon = True
            shutdown_thread.start()

            return (
                jsonify(
                    {{
                        "status": "success",
                        "message": "Shutdown initiated",
                        "pc": PC_NAME,
                        "pc_number": PC_NUMBER,
                        "timestamp": time.time(),
                    }}
                ),
                200,
            )
        else:
            logger.warning(f"Invalid command received: {{command}}")
            return (
                jsonify({{"status": "error", "message": f"Invalid command: {{command}}"}}),
                400,
            )

    except Exception as e:
        logger.error(f"Error processing shutdown request: {{e}}")
        send_status_to_esp32("Error processing request")
        return jsonify({{"status": "error", "message": str(e)}}), 500


@app.route("/status", methods=["GET"])
def status():
    """Health check endpoint"""
    return (
        jsonify(
            {{
                "status": "online",
                "pc": PC_NAME,
                "pc_number": PC_NUMBER,
                "platform": sys.platform,
                "timestamp": time.time(),
            }}
        ),
        200,
    )


@app.route("/ping", methods=["GET"])
def ping():
    """Simple ping endpoint for connectivity testing"""
    return jsonify({{"pong": True, "pc": PC_NAME}}), 200


if __name__ == "__main__":
    logger.info(f"Starting {{PC_NAME}} (PC{{PC_NUMBER}}) shutdown server on port 5000...")
    logger.info(f"Platform: {{sys.platform}}")
    logger.info(f"Attempting to register with ESP32 at {{ESP32_IP}}...")

    # Try to register with ESP32
    if send_status_to_esp32("Server starting..."):
        logger.info("Successfully registered with ESP32")
        send_status_to_esp32("Online")
    else:
        logger.warning("Failed to register with ESP32 - continuing anyway")

    logger.info("Server ready! Listening for shutdown commands...")
    logger.info("Press Ctrl+C to stop")

    try:
        # Run Flask server
        app.run(host="0.0.0.0", port=5000, debug=False)
    except KeyboardInterrupt:
        logger.info("Server stopped by user")
        send_status_to_esp32("Server stopped")
    except Exception as e:
        logger.error(f"Server error: {{e}}")
        send_status_to_esp32("Server error")
'''

    def get_run_batch_template(self, pc_num, pc_config, esp32_ip):
        """Generate run batch file for a specific PC"""
        return f'''@echo off
REM {pc_config['name']} Shutdown Server Launcher
REM This batch file runs the {pc_config['name']} shutdown script with administrator privileges
REM 
REM Installation:
REM 1. Place this file in the same directory as pc{pc_num}_shutdown.py
REM 2. Right-click and "Run as administrator" 
REM 3. Or set up Task Scheduler to run at startup with highest privileges
REM
REM Generated by ESP32 PC Controller Template Generator

REM Change to the directory where this batch file is located
cd /d "%~dp0"

title {pc_config['name']} Shutdown Server

echo ========================================
echo      {pc_config['name']} Shutdown Server
echo ========================================
echo.
echo Starting shutdown server for {pc_config['name']}...
echo ESP32 IP: {esp32_ip}
echo Listen Port: 5000
echo PC IP: {pc_config['ip_address']}
echo MAC Address: {pc_config['mac_address']}
echo.
echo This window must remain open for remote shutdown to work.
echo Press Ctrl+C to stop the server.
echo.

REM Check if Python is available
python --version >nul 2>&1
if errorlevel 1 (
    echo ERROR: Python is not installed or not in PATH
    echo Please install Python 3.7+ and try again
    echo.
    pause
    exit /b 1
)

REM Check if the Python script exists
if not exist "{pc_config['name'].lower()}_shutdown.py" (
    echo ERROR: {pc_config['name'].lower()}_shutdown.py not found in current directory
    echo Please ensure the script is in the same folder as this batch file
    echo Current directory: %CD%
    echo.
    pause
    exit /b 1
)

REM Install required packages if needed
echo Checking Python dependencies...
python -c "import flask, requests" >nul 2>&1
if errorlevel 1 (
    echo Installing required Python packages...
    python -m pip install flask requests
    if errorlevel 1 (
        echo ERROR: Failed to install required packages
        echo Please run: pip install flask requests
        echo.
        pause
        exit /b 1
    )
)

echo Dependencies OK. Starting server...
echo.

REM Run the Python script
python {pc_config['name'].lower()}_shutdown.py

REM If we get here, the script has stopped
echo.
echo ========================================
echo Server has stopped.
echo ========================================
pause
'''

    def get_service_batch_template(self, pc_num, pc_config):
        """Generate service installer batch file for a specific PC"""
        return f'''@echo off
REM {pc_config['name']} Service Installer
REM This script creates a Windows Task Scheduler entry to auto-start {pc_config['name']} shutdown server
REM Run this script as Administrator to set up automatic startup
REM
REM Generated by ESP32 PC Controller Template Generator

title {pc_config['name']} Service Installer

echo ========================================
echo     {pc_config['name']} Auto-Startup Installer
echo ========================================
echo.

REM Check if running as administrator
net session >nul 2>&1
if errorlevel 1 (
    echo ERROR: This script must be run as Administrator
    echo Right-click and select "Run as administrator"
    echo.
    pause
    exit /b 1
)

echo Setting up automatic startup for {pc_config['name']} shutdown server...
echo.

REM Get current directory
set "SCRIPT_DIR=%~dp0"
set "BATCH_FILE=%SCRIPT_DIR%run_{pc_config['name'].lower()}.bat"

REM Check if batch file exists
if not exist "%BATCH_FILE%" (
    echo ERROR: run_{pc_config['name'].lower()}.bat not found in current directory
    echo Please ensure all files are in the same folder
    echo.
    pause
    exit /b 1
)

echo Creating Task Scheduler entry...
echo Task Name: {pc_config['name']}_Shutdown_Server
echo Script Path: %BATCH_FILE%
echo.

REM Create the scheduled task
schtasks /create /tn "{pc_config['name']}_Shutdown_Server" /tr "\\"%BATCH_FILE%\\"" /sc onstart /ru "SYSTEM" /rl highest /f

if errorlevel 1 (
    echo ERROR: Failed to create scheduled task
    echo Please check Windows Task Scheduler manually
    echo.
    pause
    exit /b 1
)

echo.
echo ========================================
echo Installation completed successfully!
echo ========================================
echo.
echo The {pc_config['name']} shutdown server will now start automatically when Windows boots.
echo.
echo To manage the service:
echo - Open Task Scheduler
echo - Look for "{pc_config['name']}_Shutdown_Server" task
echo - Right-click to Enable/Disable/Delete
echo.
echo To test the service:
echo - Restart your computer, or
echo - Run: schtasks /run /tn "{pc_config['name']}_Shutdown_Server"
echo.
pause
'''

    def get_pc_readme_template(self, pc_num, pc_config, esp32_ip):
        """Generate README for a specific PC"""
        return f'''PC{pc_num} ({pc_config['name']}) - ESP32 Controller Setup
========================================================

This folder contains all files needed to set up remote shutdown control for:
- PC Name: {pc_config['name']}
- IP Address: {pc_config['ip_address']}
- MAC Address: {pc_config['mac_address']}

FILES IN THIS FOLDER:
--------------------
1. pc{pc_num}_shutdown.py        - Python shutdown server script
2. run_pc{pc_num}.bat            - Manual launcher (run as administrator)
3. install_pc{pc_num}_service.bat - Auto-startup installer (run as administrator)
4. README.txt                    - This file

QUICK SETUP:
-----------
1. Copy this entire folder to {pc_config['name']}
2. Right-click "run_pc{pc_num}.bat" and select "Run as administrator"
3. Test shutdown from ESP32 web interface at http://{esp32_ip}
4. If working, run "install_pc{pc_num}_service.bat" as administrator for auto-startup

CONFIGURATION:
-------------
ESP32 IP: {esp32_ip}
PC{pc_num} Listen Port: 5000
Button GPIOs: ON={pc_config['on_button_gpio']}, OFF={pc_config['off_button_gpio']}

REQUIREMENTS:
------------
- Python 3.7+ installed
- Internet connection for package installation
- Windows firewall allows port 5000
- Administrator privileges for shutdown commands

TROUBLESHOOTING:
---------------
- If Python not found: Install Python from python.org
- If packages fail: Run "pip install flask requests" manually
- If firewall blocks: Allow port 5000 in Windows Firewall
- If shutdown fails: Check administrator privileges

For more help, see the main project README.md and docs/ folder.

Generated by ESP32 PC Controller Template Generator
'''


def main():
    """Main function to run the template generator"""
    generator = TemplateGenerator()
    
    try:
        generator.generate_all()
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return 1
    
    return 0


if __name__ == "__main__":
    exit(main())
